#include <filesystem>
#include <fstream>

#include <console.hpp>
#include <uva/file.hpp>

#include <lexer/lexer.hpp>
#include <parser/parser.hpp>

int main(int argc, char** argv)
{
    if(argc < 2) {
        uva::console::log_error("Usage: uvalang <file>");
        return 1;
    }

    std::filesystem::path file_path = std::filesystem::absolute(argv[1]);

    if(!std::filesystem::exists(file_path)) {
        uva::console::log_error("input file not found");
        return 1;
    }

    if(!std::filesystem::is_regular_file(file_path)) {
        uva::console::log_error("input file is not a regular file");
        return 1;
    }

    std::string source = uva::file::read_all_text<char>(file_path);

    uva::lang::lexer l(file_path.string(), source);

    uva::lang::parser p;
    uva::lang::parser::ast_node root_node = p.parse_all(l);

    std::filesystem::path output_folder = std::filesystem::current_path();
    std::filesystem::path tmp_folder = output_folder / "tmp";

    if(!std::filesystem::exists(tmp_folder)) {
        std::filesystem::create_directory(tmp_folder);
    }

    std::filesystem::path output_file = tmp_folder / file_path.filename();
    output_file.replace_extension(".cpp");

    std::filesystem::path executable_path = output_folder / file_path.stem();

    std::ofstream output(output_file);

    output << "/* Generated by uvalang */" << std::endl;
    output << "/* Source file: " << file_path << " */" << std::endl;
    output << "/* Output file: " << output_file << " */" << std::endl;
    output << std::endl;

    output << "#include <stdio.h>" << std::endl;

    output << "void print(const char* str) { printf(\"%s\", str); }" << std::endl;

    output << std::endl;

    for(auto& child : root_node.childrens()) {
        switch(child.type())
        {
            case uva::lang::parser::ast_node_type::ast_node_classdecl: {
                std::string class_name = child.decname();
                
                output << "class " << class_name << " {" << std::endl;
                output << "public:" << std::endl;
                output << "\t" << class_name << "() {}" << std::endl;
                output << "\t~" << class_name << "() {}" << std::endl;

                for(auto& class_child : child.childrens()) {
                    switch(class_child.type())
                    {
                        case uva::lang::parser::ast_node_type::ast_node_fn_decl: {
                            std::string method_name = class_child.decname();

                            output << "\tint " << method_name << "()";
                            
                            uva::lang::parser::ast_node* method_block = class_child.child_from_type(uva::lang::parser::ast_node_type::ast_node_context);

                            if(method_block) {
                                output << " {" << std::endl;

                                for(auto& method_block_child : method_block->childrens()) {
                                    switch(method_block_child.type())
                                    {
                                        case uva::lang::parser::ast_node_type::ast_node_vardecl: {
                                            std::string var_name = method_block_child.decname();
                                            output << "\t\tint " << var_name << ";" << std::endl;
                                        }
                                        break;
                                        case uva::lang::parser::ast_node_type::ast_node_fn_call: {
                                            std::string function_name = method_block_child.decname();
                                            output << "\t\t" << function_name << "(";

                                            uva::lang::parser::ast_node* fn_params = method_block_child.child_from_type(uva::lang::parser::ast_node_type::ast_node_fn_params);

                                            if(fn_params) {
                                                auto fn_params_children = fn_params->childrens();
                                                for(size_t i = 0; i < fn_params_children.size(); i++) {
                                                    if(i > 0) {
                                                        output << ", ";
                                                    }
                                                    auto& fn_param = fn_params_children[i];
                                                    switch(fn_param.type())
                                                    {
                                                        case uva::lang::parser::ast_node_type::ast_node_valuedecl: {
                                                            switch(fn_param.token().kind())
                                                            {
                                                                case uva::lang::lexer::token_kind::token_string:
                                                                    output << "\"" << fn_param.token().content() << "\"";
                                                                break;
                                                                case uva::lang::lexer::token_kind::token_integer:
                                                                    output << fn_param.token().content();
                                                                break;
                                                                case uva::lang::lexer::token_kind::token_float:
                                                                    output << fn_param.token().content();
                                                                break;
                                                                default:
                                                                    break;
                                                            }
                                                        }
                                                        break;
                                                        default:
                                                            break;
                                                    }
                                                }
                                            }

                                            output << ");" << std::endl;
                                        }
                                        break;
                                        case uva::lang::parser::ast_node_type::ast_node_fn_return: {
                                            auto return_value = method_block_child.child_from_type(uva::lang::parser::ast_node_type::ast_node_valuedecl);
                                            output << "\t\treturn " << return_value->token().content() << ";" << std::endl;
                                        }
                                        break;
                                        default:
                                            break;
                                    }
                                }

                                output << "\t}" << std::endl;
                            } else {
                                output << ";" << std::endl;
                            }

                        }
                        break;
                        default:
                            break;
                    }

                    output << std::endl;
                }

                output << "};" << std::endl;
            }
            break;
            default:
                break;
        }
    }

    output << std::endl;

    output << "int main() {" << std::endl;
    output << "\tApplication" << " app;" << std::endl;
    output << "\treturn app.run();" << std::endl;
    output << "}" << std::endl;

    output.close();

    system(("g++ " + output_file.string() + " -o " + executable_path.string()).c_str());

    // Run

    system(executable_path.string().c_str());

    return 0;
}